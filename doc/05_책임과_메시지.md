# 05. 책임과 메시지

## 적합한 책임

책임이 수행 방법을 제한할 정도로 너무 구체적이면 객체의 자율성을 제한하게 된다. 객체지향 세계는 자율적인 객체들의 공동체라는 점을 명심해야 한다. 물론 그렇다고 해서 포괄적이고 추상적인 책임을 선택한다고 해서 무조건 좋은 것은 아니다. 포괄적이고 추상적인 책임은 협력을 좀 더 다양한 환경에서 재사용할 수 있도록 유연성을 제공한다. 그러나 책임은 협력에 참여하는 의도를 명확하게 설명할 수 있는 수준 내에서 추상적이어야 한다.

자율적인 책임의 특징은 객체가 `어떻게 (how)` 해야 하는지가 아니라 `무엇 (what)`을 해야 하는지를 설명해야 한다는 것이다. 앨리스의 예시에서 `증언한다`라는 책임은 모자 장수가 협력을 위해 무엇을 해야 하는지는 결정하지만 어떻게 해야 하는지에 대해서는 언급이 없다. 증언할 방법은 모자 장수가 자율적으로 선택할 수 있다.

## 메시지

하나의 객체는 `메시지`를 전송함으로써 다른 객체에 접근한다. 사용자에 대한 객체의 독립성과 객체지향 개념을 구현한 초기 언어들의 일부 문법 때문에 객체의 행동을 유발하는 행위를 가리켜 `메시지-전송`이라고 한다. 메시지-전송 메커니즘은 객체가 다른 객체에 접근할 수 있는 유일한 방법이다. 송신자는 메시지 전송을 통해서만 다른 객체의 책임을 요청할 수 있고, 수신자는 오직 메시지 수신을 통해서만 자신의 책임을 수행할 수 있다.

메시지 전송은 `수신자`와 `메시지`의 조합이다. 메시지는 `메시지 이름 (message name)`과 `인자 (argument)`의 조합이다. 결국 메시지 전송은 수신자, 메시지 이름, 인자의 조합이 된다. 객체가 수신할 수 있는 메시지의 모양이 객체가 수행할 책임의 모양을 결정한다.

## 메서드

`메서드`는 객체가 메시지를 처리하기 위해 내부적으로 선택하는 방법이다. 객체는 메시지를 수신하면 먼저 해당 메시지를 처리할 수 있는지 여부를 확인한다. 메시지를 처리할 수 있다고 판단되면 자신에게 주어진 책임을 다하기 위해 메시지를 처리할 방법인 메서드를 선택하게 된다. 객체지향 프로그래밍 언어에서 메서드는 클래스 안에 포함된 함수 또는 프로시저를 통해 구현된다. 따라서 어떤 객체에게 메시지를 전송하면 결과적으로 메시지에 대응되는 특정 메서드가 실행된다.

메시지를 수신한 객체가 실행 시간에 메서드를 선택할 수 있다는 사실은 다른 프로그래밍 언어와 객체지향 프로그래밍 언어를 구분 짓는 핵심적인 특징 중 하나다. 이것은 프로시저 호출에 대한 실행 코드를 컴파일 시간에 결정하는 절차적인 언어와 확연히 구분되는 특징이다.

## What/Who 사이클

책임-주도 설계의 핵심은 어떤 행위가 필요한지를 먼저 결정한 후에 이 행위를 수행할 객체를 결정하는 것이다. 이 과정을 흔히 `What/Who 사이클`이라고 한다. What/Who 사이클이라는 용어가 의미하는 것은 객체 사이의 협력 관계를 설계하기 위해서는 먼저 `어떤 행위 (what)`를 수행할 것인지를 결정한 후에 `누가 (who)` 그 행위를 수행할 것인지를 결정해야 한다는 것이다. 여기서 `어떤 행위`가 바로 메시지다. 메시지가 결정된 후에야 수신할 후보를 선택하는 것이다.

## 책임, 메시지, 그리고 인터페이스

객체가 메시지를 수신했을 때 적절한 객체의 책임이 수행된다. 메서드란 메시지를 수신했을 때 책임을 수행하는 방법을 의미한다. 메시지와 메서드의 구분은 객체를 외부와 내부라는 두 개의 명확하게 분리된 영역을 구분하는 동시에 다형성을 통해 다양한 타입의 객체를 수용할 수 있는 유연성을 부과한다.

메시지를 기반으로 한 두 객체 사이의 낮은 결합도가 설계를 유연하고 확장 가능하며 재사용 가능하게 만들어준다. 객체지향 프로그래밍에서 다형성은 송신자와 수신자 간의 객체 타입에 대한 결합도를 메시지에 대한 결합도로 낮춤으로써 달성된다.

인터페이스는 객체가 책임을 수행하기 위해 외부로부터 메시지를 받기 위한 통로다. 인터페이스는 다른 객체와 협력하기 위한 접점인 것이다. 객체의 인터페이스는 객체가 수신할 수 있는 메시지의 목록으로 채워진다. 메시지로 구성된 공용 인터페이스는 객체의 외부와 내부를 명확하게 분리한다. 객체의 외부는 인터페이스고 내부는 구현이다.

## 인터페이스와 구현의 분리 원칙

훌륭한 객체란 구현을 모른 채 인터페이스만 알면 쉽게 상호작용할 수 있는 객체를 의미한다. 이것은 객체를 설계할 때 외부에 노출되는 인터페이스와 객체의 내부에 숨겨지는 구현을 명확하게 분리해서 고려해야 한다는 것을 의미한다. 이를 `인터페이스와 구현의 분리 (separation of interface and implementation) 원칙`이라고 한다. 인터페이스와 구현의 분리 원칙이 중요한 이유는 소프트웨어는 항상 변경되기 때문이다. 수많은 객체들이 물고 물리며 돌아가는 객체지향 공동체에서 어떤 객체를 수정했을 때 어떤 객체가 영향을 받는지를 판단하는 것은 매우 어렵다. 객체의 모든 것이 외부에 공개되어 있다면 작은 부분을 수정하더라도 큰 파급 효과가 생길 수 있다. 그래서 변경해도 무방한 안전 지대와 변경했을 경우와 외부에 영향을 미치는 위험 지대를 구분하는 선택을 하게 되는 것이다. 여기서 안전 지대가 객체의 내부인 구현이고 위험 지대가 객체의 외부인 공용 인터페이스다. 변경에 대한 안전 지대를 만드는 것은 객체를 자율적인 존재로 만드는 데도 기여한다.

결론적으로 객체 설계의 핵심은 객체를 두 개의 분리된 요소로 분할해 설계하는 것이다. 그것은 바로 외부에 공개되는 인터페이스와 내부에 감춰지는 구현이다. 객체가 가져야 할 상태와 메서드 구현은 객체 내부에 속한다.

## 캡슐화

인터페이스와 구현을 분리한다는 것은 변경될 만한 부분을 객체의 내부에 숨겨 놓는다는 것을 의미한다. 일반적으로 이 원칙을 수행하기 위한 객체 설계 방법을 `캡슐화`라고 한다. 객체의 자율성을 보존하기 위해 구현을 외부로부터 감추는 것이다. 객체는 상태와 행위를 함께 캡슐화함으로써 협력적이고 자율적인 존재가 될 수 있다.

객체는 상태와 행동을 하나의 단위로 묶는 자율적인 실체다. 이 관점에서의 캡슐화를 `데이터 캡슐화`라고 한다. 객체는 상태와 행위를 한데 묶은 후 외부에서 반드시 접근해야만 하는 행위만 골라 공용 인터페이스를 통해 노출시킨다. 따라서 데이터 캡슐화는 인터페이스와 구현을 분리하기 위한 전제 조건이다. 프로그래밍 관점에서 상태는 주로 데이터로 구현되고 행동은 프로세스로 구현된다. 과거 전통적인 개발 방법은 데이터와 프로세스를 엄격하게 분리하지만 객체지향에서는 데이터와 프로세스를 객체라는 하나의 틀 안으로 함께 묶어 놓음으로써 객체의 자율성을 보장한다.

자율적인 객체는 공용 인터페이스를 수정하지 않는 한 자신과 협력하는 외부 객체에 영향을 미치지 않고 내부의 구현을 자유롭게 수정할 수 있다. 책임이 자율적일수록 `추상화`되며, `응집도`가 높아지고, `결합도`가 낮아지며, `캡슐화`가 증진되고, `인터페이스와 구현이 명확히 분리`되며, 설계의 `유연성`과 `재사용성`이 향상된다.
