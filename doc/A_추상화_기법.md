# 추상화 기법

추상화는 도메인의 복잡성을 단순화하고 직관적인 멘탈 모델을 만드는 데 사용할 수 있는 가장 기본적인 인지 수단이다.

추상화 기법에는 3가지 종류가 있다. 각 추상화 기법은 복잡성을 낮추기 위해 사물의 특정한 측면을 감춘다.

- 분류와 인스턴스화: 분류는 구체적인 세부 사항을 숨기고 인스턴스 간에 공유하는 공통적인 특성을 기반으로 범주를 형성하는 과정이다. 분류의 역은 범주로부터 객체를 생성하는 인스턴스화 과정이다.

- 일반화와 특수화: 일반화는 범주 사이의 차이를 숨기고 범주 간에 공유하는 공통적인 특성을 강조한다. 일반화의 역을 특수화라고 한다.

- 집합과 분해: 집합은 부분과 관련된 세부 사항을 숨기고 부분을 사용해서 전체를 형성하는 과정을 가리킨다. 집합의 반대 과정은 전체를 부분으로 분리하는 분해 과정이다.

## 상속

프로그래밍 언어를 이용해 일반화와 특수화 관계를 구현하는 가장 일반적인 방법은 클래스 간의 상속을 이용하는 것이다. 그런데 모든 상속 관계가 일반화 관계는 아니다. 프로그램 내의 두 클래스 간에 상속 관계가 존재할 때 이 관계를 반드시 일반화 관계라고 할 수는 없다.

일반화의 원칙은 한 타입이 다른 타입의 서브타입이 되기 위해서는 슈퍼타입에 순응해야 한다는 것이다. 순응에는 `구조적인 순응 (structural conformance)`과 `행위적인 순응 (behavioral conformance)`의 두 가지 종류가 있다. 두 가지 모두 특정 기대 집합에 대해 서브타입의 슈퍼타입에 대한 대체 가능성을 의미한다.

구조적인 순응은 타입의 내연과 관련된 100% 규칙을 의미한다. 즉, 서브타입은 슈퍼타입이 가지고 있는 속성과 연관관계 면에서 100% 일치해야 한다.

행위적인 순응은 타입의 행위에 관한 것이며, 서브타입은 슈퍼타입을 행위적으로 대체 가능해야 한다. 행위적인 순응을 흔해 `리스코프 치환 원칙 (Liskov Substitution Principle, LSP)`이라고 한다.

상속의 `또 다른 용도`는 코드 중복을 방지하고 공통 코드를 재사용하기 위한 언어적 메커니즘을 제공하는 것이다. 만약 한 클래스가 다른 클래스를 상속한다면 상속하는 타입은 부모 클래스의 데이터와 메서드를 사용하고, 수정하고, 확장할 수 있다. 앞서 설명한 일반화와 특수화 관계를 구현하기 위해 상속을 이용한 것하고는 다른 이야기인 것이다. 어떤 프로그래밍 언어도 상속이 그 자체로 대체 가능성을 만든다는 것을 보장하지 않는다.

상속은 `서브타이핑 (subtyping)`과 `서브클래싱 (subclassing)`의 두 가지 용도로 사용될 수 있다. 서브클래스가 슈퍼클래스를 대체할 수 있는 경우 이를 서브타이핑이라고 한다. 서브클래스가 슈퍼클래스를 대체할 수 없는 경우에는 서브클래싱이라고 한다. 서브타이핑은 설계의 유연성이 목표인 반면 서브클래싱은 코드의 중복 제거와 재사용이 목적이다. 흔히 서브타이핑을 `인터페이스 상속 (interface inheritance)`이라고 하고, 서브클래싱을 `구현 상속 (implementation inheritance)`이라고 한다.

다시 한번 강조하자면 클래스가 다른 클래스를 상속받았다는 사실만으로 두 클래스 간의 관계가 서브타이핑인지, 서브클래싱인지 여부를 결정할 수는 없다. 즉 클래스 상속만을 보고 대체 가능성을 판단할 수는 없다는 것이다. 서브타이핑의 전제 조건은 대체 가능성이기 때문에 서브타이핑인지 여부를 확인하려면 클라이언트 관점에서 실제로 어떻게 사용되고 있는지를 확인해야 한다.

요약하면 일반화를 위한 서브타이핑은 특정 기대 집합에 대한 서브타입과 슈퍼타입 간의 구조적, 또는 행위적 순응 관계를 의미하며, 대체 가능성을 내포한다. 상속은 서브타이핑을 프로그래밍 언어적으로 구현하는 데 사용될 수 있지만 모든 상속이 서브타이핑인 것은 아니다. 서브클래스가 슈퍼클래스를 대체할 수 없고 단지 코드만 공유하고 있다면 서브타이핑이 아니라 서브클래싱이라고 한다. 가능한 모든 상속 관계가 서브타이핑의 대체 가능성을 준수하도록 주의 깊게 사용하는 것은 코드를 유연하게 만들고 재사용성을 높이는 한 가지 방법이다.

여기까지 읽었을 때 인터페이스 상속, 구현 상속이 그래서 코드로 어떻게 다른 것인지 궁금해져서 생각해봤다. 단순하게 생각해봤을 때 인터페이스 상속은 추상 메서드가 인터페이스에서 선언되어 있고 그 인터페이스를 상속받은 클래스에서 오버라이드하는 경우다. 반면 구현 상속의 경우 어떤 클래스에 메서드가 구현되어 있는데 그것을 상속받은 자식 클래스에서 오버라이드하는 경우다. 여기에서 자식 클래스는 부모 클래스를 대체할 수 없다. 왜냐면 부모 클래스의 행위를 오버라이드해서 수정했기 때문이다. 설명이 좀 부족하지만 당장은 이 정도로만 이해를 하고 넘어가자.

## 프로토타입 기반 언어의 위임 메커니즘

여러 클래스로 구성된 상속 계층에서 수신된 메시지를 이해하는 기본적인 방법은 클래스 간의 `위임 (delegation)`을 사용하는 것이다. 어떤 객체의 클래스가 수신된 메시지를 이해할 수 없다면 메시지를 클래스의 부모 클래스로 위임한다. 만약 부모 객체도 메시지를 이해할 수 없다면 자신의 부모 클래스로 다시 메시지를 위임한다. 클래스 간의 위임 사슬은 계층 내의 어떤 클래스가 메시지를 처리하거나 최상위 부모 클래스에 위임될 때까지 계속된다.

클래스가 없는 프로토타입 기반 언어에서 상속은 객체와 객체 간의 관계로 이루어진다. 프로토타입 기반 언어에서 메시지는 클래스 기반의 객체지향 언어와 동일하게 위임 메커니즘에 의해 처리된다. 차이점이라면 자식 클래스와 부모 클래스 사이가 아니라 `자식 객체와 부모 객체 사이`에 위임이 이루어진다는 점이다. 메시지를 수신한 객체는 자신이 메시지를 이해할 수 없을 경우 부모 객체에게 위임한다. 이 메시지 위임 사슬은 계층 내의 어떤 객체가 메시지를 처리하거나 최상위 부모 객체에 위임될 때까지 계속 된다.

클래스 기반 언어와 프로토타입 기반 언어 모두 위임 메커니즘을 기반으로 메시지를 해석할 수 있는 대상을 선택한다. 단지 위임이 클래스를 기준으로 이루어지는지, 아니면 객체를 기준으로 이루어지는지 여부가 다를 뿐이다.

## 합성 관계와 연관 관계

일반적으로 합성 관계로 연결된 객체는 포함하는 객체가 제거될 때 내부에 포함된 객체도 함께 제거된다. 이에 반해 연관 관계로 연결된 두 객체는 생명주기와 관련된 어떤 제약도 부과하지 않는다. 연관 관계로 연결된 두 객체는 독립적으로 제거될 수 있다. 합성 관계는 생명주기 측면에서 연관 관계보다 더 강하게 객체들을 결합한다.

## 패키지

합성 관계를 이용해 커다란 객체 그룹을 단순화하더라도 클래스의 수가 많아지면 많아질수록 복잡한 클래스 간의 의존성을 관리하는 일은 어려워진다. 그래서 구조를 단순화하기 위해서 서로 관련성이 높은 클래스 집합을 논리적인 단위로 통합할 필요가 있다. 이렇게 상공에서 바라본 소프트웨어의 전체적인 구조를 표현하기 위해 관련된 클래스 집합을 하나의 논리적인 단위로 묶는 구성 요소를 `패키지 (package)` 또는 `모듈 (module)`이라고 한다.

패키지를 이용하면 시스템의 전체적인 구조를 이해하기 위해 한 번에 고려해야 하는 요소의 수를 줄일 수 있다. 또한 개별 클래스가 아닌 클래스의 집합을 캡슐화함으로써 전체적인 복잡도를 낮출 수 있다. 함께 협력하는 응집도 높은 클래스 집합을 하나의 패키지 내부로 모으면 코드를 이해하기 위해 패키지 경계를 넘나들 필요가 줄어든다.

합성 관계가 내부에 포함된 객체들의 존재를 감춤으로써 내부 구조를 추상화하는 것처럼 패키지는 내부에 포함된 클래스들을 감춤으로써 시스템의 구조를 추상화한다.
